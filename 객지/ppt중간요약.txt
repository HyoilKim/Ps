오버로딩은 메소드명동일 , 파라미터 개수,타입 다름(변수명, 리턴타입 상관x)
오버로딩은 메소드명, 파라미터, 리턴타입 동일
오버로딩과 타입컨버젼??
생성자안에서 다른 메소드 호출가능, 디폴트 생성자 자동생성(다른 생성자있으면 생성x)
인스턴스 디폴트 변수 초기화(불린-false, primitives-각 타입의 zero, calss-null)
로컬 변수는 자동초기화 x
스태틱 메소드는 this 가지고 있지 않다, 스태틱은 넌스태틱변수와 메소드 호출 불가능
스태틱 변수는 모든 클래스에서 접근가능, 선언과 동시에 초기화(안해주면 default 값으로 자동초기화)
스태틱 변수는 꼭 퍼블릭이 아니어도된다
math 클래스(스태틱 클래스), math클래스는 스태틱 랜덤함수를 포함하고 있다
wrapper클래스(Charcter클래스 안의 여러 메소드 존재)
모든 변수는 메모리에 적재된다
(primitive type 변수들은 메인메모리에 할당된다)
(클래스 type은 메모리에 저장된 위치의 주소(참조)가 할당)
자바에서 모든 파라미터는 call-by-value이다but 클래스 타입 파라미터는 call-byreference처럼 작동된다
(파라미터인 참조값은 변하지 않지만 참조를 하고 있는 class는 변한다 -> call-by-value임은 맞다)
널을 참조하면 널포인터익셉션 에러가 발생
new operator는 오브젝트가 만들어진 메모리의 위치 참조값을 리턴한다
Double.parseDouble(string)
카피 컨스트럭터 하는 방법(생성자를 통해, 하나의 객체 값을 다른 객체로 할당하는 것을 통해, clone()메소드를 통해)
immutable class(인스턴스 내용 절대 변하지x)
shallow copy(얕은 복사 - 원본 참조변수의 참조 값만 복사, 한쪽의 수정이 양쪽에 영향끼침)
deep copy(깊은 복사 - 원본 참조변수의 참조하는 개체를 복사생성 후 본사본 참조변수를 가르킴, 한쪽의 수정이 다른 한쪽에 영향끼치지x)
클래스 패스에서 lib까지는 /로 접근 하고, 이후는 패키지니까 .으로 접근
서브디렉토리는 자동적으로 import되지 않는다, 클래스패스를 추가하지 않으면 현재 디렉토리만 찾음
캐릭터 배열은 스트링이 아니지만 convert할 수 는 있다
Array도 오브젝트이고 어레이 타입 변수는 어레이 오브젝트가 생성된 주소 값을 참조함
어래이 파라미터도 클래스처럼 call-by-reference'처럼' 쓰인다
for each구문 : for(arrayType vairableName : ArrayName) statement
for(double element : a){ element = 0.0 } // int[] a = new int()
가변인자 func(String...arr){for(String a:arr) statement;} - arr배열을 만든다, 파라미터 마지막에 선언
배열의 getArray에서는 copy한 것을 return해줘서 원래 값을 privacy하게하라  
Arrays.sort(배열변수이름) : 배열내부값을변경
System.out.println(enum 타입의 변수) : toString이 있어서 출력가능
WorkDay[] day = WorkDay.values() :  각 원소들을 배열로 만듬
Ragged Arrays : 멀티 디멘져일 때 배열의 원소마다 배열 객체 크기가 달라도 ㄱㅊ
오버라이드, 오버로드, 슈퍼 컨스트럭터, this 컨스트럭터, final modifier(오버라이드x)
상속할 때 클래스는 기본적으로 디폴트 패키지에 있는 것을 잊지마라
스태틱은 상속된다(오버라이딩x, 부모 스태틱 변수와 자식 스태틱 변수명은 같아도 따로 쓸 수 있음)
super.super.toString(슈퍼는 반복해서 쓸 수 없다)
모든클래스는 Object클래스를 상속받는다(toString, equals 오버라이드 가능 not 오버로드)
eqauls안에 getClass()대신 instancof 사용하는 것 추천
부모 인스턴스.equals = 자식 인스턴스 (true)
자식 인스턴스.equals = 부모 인스턴스 (false)
둘다 오브젝트클래스를 확인하는 오퍼레이터지만 instanceof가 더 정확
instanceof : 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해
getClass vs equals??
자바는 private,final, static methods빼고 전부 late binding한다
static methods가 late binding 될 때도 있다(??
업캐스팅 (부모 = 자식 : 자식을 부모에 대입)
다운캐스팅 (자식 = (자식변환)부모 : 부모를 자식으로 형변환(런타임에러) or 그냥 대입(컴파일에러)
카피컨스트럭터는 안되고 클론에서만 되는 경우가 있다 : ??
추상화 클래스는 인스턴스 생성x, 자식 클래스 생성자는 추상화된 부모클래스 super형태로 생성
추상화 클래스는 new로 접근 절대 ㄴㄴ (클래스안의 메소드들이 추상이 없더라도 불가능)
상속관계에서도 오버로드 된다