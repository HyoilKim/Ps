<git>
생성 후 이동
git checkout -b feature-01

Git remote branch 생성
git push origin feature-01

branch local remote 연동
git branch --set-upstream-to origin/feature-01

merge(B를 A로)
$ git checkout A
$ git merge B
<알고리즘>
머지소트
소수
피보나치
버블소트
시간복잡도
스트링거꾸로출력
public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String str = scanner.nextLine();
        
        for (int i = str.length()-1; i>=0; i--){
            System.out.print(str.charAt(i));
        }
 
    }
스택 2개로 큐 구현하기

<자바>
(오버라이딩 오버로딩)
오버로딩은 클래스 내부에 동일한 이름의 함수를 여러 개 정의하는 것. 이때, 함수명은 같아야한다. 인자 타입과 개수, 리턴 타입은 서로 달라도 된다. 
오버라이딩은 상속으로 물려받은 자료나 메소드를 그대로 사용하지 않고 자신이 새로 만들어서 사용하는 것이다. 
이때, 함수명, 인자 타입과 개수, 리턴 타입(상속관계면 달라도)이 모두 같아야 한다. 
상속받은 부모의 메소드는 추상화 되어 있기 때문에 자식에게 맞게 재정의가 필요하다. 

스태틱
(가비지컬렉션)
프로그램이 동적으로 할당했던 메모리 영역 중에서 필요없게 된 영역을 해제하는 기능이다.

(자바특징)
추상화:
상속:
캡슐화:
다형성: 다형성이란 같은 자료형에 여러 가지 객체를 대입하여 다양한 결과를 얻어내는 성질을 의미한다. 
다
<os>
(프로세스와 쓰레드)
프로세스: 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
쓰레드: 프로세스 내에서 실행되는 여러 흐름의 단위

(LRU & 페이지폴트)

(멀티프로세스 대신 멀티쓰레드를 사용하는 이유)
1. 자원의 효율성 증대
멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
-> 프로세스 간의 Context Switching시 단순히 CPU 레지스터 교체 뿐만 아니라 RAM과 CPU 사이의 캐쉬 메모리에 대한 데이터까지 초기화되므로 오버헤드가 크기 때문
스레드는 프로세스 내의 메모리를 공유하기 때문에 독립적인 프로세스와 달리 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들게 된다.
2. 처리 비용 감소 및 응답 시간 단축
또한 프로세스 간의 통신(IPC)보다 스레드 간의 통신의 비용이 적으므로 작업들 간의 통신의 부담이 줄어든다.
-> 스레드는 Stack 영역을 제외한 모든 메모리를 공유하기 때문
프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠르다.
-> Context Switching시 스레드는 Stack 영역만 처리하기 때문

(데드락)
-정의
첫 번째 스레드는 두 번째 스레드가 들고 있는 객체의 락이 풀리기를 기다리고 있고, 두 번째 스레드 역시 첫 번째 스레드가 들고 있는 객체의 락이 풀리기를 기다리는 상황을 일컷는다.
모든 스레드가 락이 풀리기를 기다리고 있기 때문에, 무한 대기 상태에 빠지게 된다. 이런 스레드를 교착상태에 빠졌다고 한다.
-조건
두 개 이상의 프로세스가 자원 접근을 기다리는데, 그 관계에 사이클이 존재

(기아상태)
우선순위가 높은 프로세스가 지속적으로 발생하여 우선순위가 낮은 프로세스가 실행되지 않고
 이러한 현상이 장기간 계속되는 상태를 말한다. 이를 해결하기 위해 에이징기법을 사용하는데, 
에이징기법이란 우선순위가 낮아서 오래 대기한 프로세스의 우선순위를 점차적으로 높여주는 정책이다.
(히트비율 높이는 법)
(캐시쓰는이유)

<디자인패턴>
 디자인 패턴 (Design Patterns) 이란?
오랜동안 많은 사람들에 의해 좋다고 검증된 프로그래밍 패턴. 
사람들이 수많은 시간동안 프로그램으로 여러 형태의 문제들을 해결해왔는데,
문제의 타입별로 해결하기 좋은 프로그래밍 패턴들이 있다는 것이 알려졌다.

(MVC패턴)
(model)
1. 사용자가 편집하길 원하는 모든 데이터를 가지고 있어야 한다.
2. 뷰나 컨트롤러에 대해서 어떤 정보도 알지 말아야 한다.
3. 변경이 일어나면, 변경 통지에 대한 처리방법을 구현해야만 한다.
(view)
1. 모델이 가지고 있는 정보를 따로 저장해서는 안된다.
2. 모델이나 컨트롤러와 같이 다른 구성요소들을 몰라야 된다.
3. 변경이 일어나면 변경통지에 대한 처리방법을 구현해야만 한다.
(controller)
1. 모델이나 뷰에 대해서 알고 있어야 한다.
2. 모델이나 뷰의 변경을 모니터링 해야 한다.
(사용이유)
사용자가 보는 페이지, 데이터처리, 그리고 이 2가지를 중간에서 제어하는 컨트롤, 
이 3가지로 구성되는 하나의 애플리케이션을 만들면 각각 맡은바에만 집중을 할 수 있게 됩니다. 
유지보수성, 애플리케이션의 확장성, 그리고 유연성이 증가하고, 
중복코딩이라는 문제점 또한 사라지게 되는 것입니다.

<기타>
허프만트리

